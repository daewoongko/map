# -*- coding: utf-8 -*-
"""통합_수정3.ipynb의 사본

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GfY31TRSfxOeOJ7dwBf0wlP_qsyDqPNW
"""

# 0. Colab 파일 업로드 (한 번만 필요)
from google.colab import files
print("필요 파일 업로드")
uploaded = files.upload()

!pip install folium pandas networkx osmnx scipy geopy openpyxl cch

# 1. 라이브러리 설치 및 import
import json
import os
import pandas as pd
import networkx as nx
import osmnx as ox
import numpy as np
from osmnx.distance import nearest_nodes
from scipy.spatial import cKDTree
from geopy.geocoders import Nominatim
from itertools import combinations, islice
from math import radians, sin, cos, sqrt, asin
from multiprocessing import Pool
import cch
from geopy.geocoders import Nominatim
from concurrent.futures import ProcessPoolExecutor
import heapq
from itertools import product
from collections import defaultdict
from datetime import datetime, time

# ───────────────────────────────────────────────────────────────────────────────
# 2. 실제 도로망 전체 로드 (network_type='drive')
#    - 서울 전역을 대상으로 OSMnx의 drive 네트워크를 가져옵니다.
#    - 로그가 너무 많으면 아래 주석을 해제하고 설정을 바꿀 수 있습니다.
# ox.config(log_console=True, use_cache=True)

road_graph = ox.graph_from_place("Seoul, South Korea", network_type="drive")

# 2.1. ROAD_COORD 캐시에 각 노드의 좌표(위도/경도) 저장
ROAD_COORD = {}
for node, data in road_graph.nodes(data=True):
    ROAD_COORD[node] = (data['y'], data['x'])

print("도로망 로드 완료")
print("  - 도로망 노드 수:", road_graph.number_of_nodes())
print("  - 도로망 엣지 수:", road_graph.number_of_edges())

"""나중에 사용자 위치도 매핑 시켜야함. walk 그래프에. 다만 아직 지도 위에 찍지는 않고, 콘솔에 좌표만 출력하므로 “지도에 매핑” 단계는 다음에 Folium Map 객체 생성 및 Marker 추가를 해주셔야 합니다."""

# Step1: 사용자 출발지, 도착지 입력 및 지오코딩

# 1.1 geolocator 초기화
geolocator = Nominatim(user_agent="route_planner")

# 1.2 지오코딩 함수 정의
def get_location(name):
    loc = geolocator.geocode(name, timeout=10)
    if not loc:
        loc = geolocator.geocode(f"{name}, Seoul", timeout=10)
    if not loc:
        raise ValueError(f"'{name}' 위치를 찾을 수 없습니다.")
    return loc.latitude, loc.longitude

# 1.3 사용자에게 출발지와 도착지 명칭 입력받기
start_name = input("출발지 (예: 고려대학교): ")
end_name   = input("도착지 (예: 한남힐스테이트): ")

# 1.4 입력값을 위경도로 변환
start_lat, start_lon = get_location(start_name)
end_lat,   end_lon   = get_location(end_name)

# 1.5 결과 확인용 출력
print(f"출발지 '{start_name}' -> 위도: {start_lat:.6f}, 경도: {start_lon:.6f}")
print(f"도착지 '{end_name}' -> 위도: {end_lat:.6f},   경도: {end_lon:.6f}")

"""Haversine 직선 거리(미터): 10065.997667197036

"""

# 예시 좌표 (출발/도착 좌표)
start_lat, start_lon = 37.570440, 126.992324
end_lat,   end_lon   = 37.497541, 127.026883

u = ox.distance.nearest_nodes(road_graph, start_lon, start_lat)
v = ox.distance.nearest_nodes(road_graph, end_lon,   end_lat)
print("출발 노드 ID:", u, "도착 노드 ID:", v)

# 노드가 제대로 선택되었다면 실제 최단 경로 길이를 구해 본다
try:
    length_m = nx.shortest_path_length(road_graph, u, v, weight='length')
    print("도로망 최단경로 길이(미터):", length_m)
except nx.NetworkXNoPath:
    print("두 노드가 같은 연결 성분에 속해 있지 않습니다. (No path)")

# 2. 유틸리티 함수 정의
def haversine(lat1, lon1, lat2, lon2):
    """두 지점 간 대원거리 계산 (미터)"""
    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])
    dlat, dlon = lat2 - lat1, lon2 - lon1
    a = sin(dlat/2)**2 + cos(lat1)*cos(lat2)*sin(dlon/2)**2
    c = 2 * asin(sqrt(a))
    return 6371000 * c

def road_distance(lat1, lon1, lat2, lon2):
    """도로망 최단 경로 길이(미터) 또는 haversine fallback"""
    try:
        u = nearest_nodes(road_graph, lon1, lat1)
        v = nearest_nodes(road_graph, lon2, lat2)
        return nx.shortest_path_length(road_graph, u, v, weight='length')
    except (nx.NetworkXNoPath, Exception):
        return haversine(lat1, lon1, lat2, lon2)

dist = road_distance(start_lat, start_lon, end_lat, end_lon)
print("도로망 기준 거리(미터):", dist)

# 지하철 관련 전역 변수 (Step3에서 채울 예정)
subway_info = {}    # { station_name: {'lat': float, 'lng': float, 'lines': set([...])}, ... }
subway_graph = {}   # { (station_name, line): [ (neighbor_station, neighbor_line, weight), ... ], ... }

# 버스 관련 전역 변수 (Step4에서 채울 예정)
bus_info = {}       # { stop_id: {'name': str, 'lat': float, 'lng': float}, ... }
bus_graph = {}      # { stop_id: [ (neighbor_stop_id, weight), ... ], ... }

# 글로벌 속도 및 패널티 설정
AVG_SPEED_KMH_GLOBAL = 18.0   # 대중교통 평균 속도 약 18 km/h (필요시 조정)
WALK_SPEED = 5.0              # 보행 속도 5 km/h
WALK_PENALTY = 3.0            # 환승 시 부과되는 보행+대기 패널티 3분

"""경강선, 인천1호선,인천2호선, 서해선,김포골드라인,용인에버라인,의정부경전철,GTXA,경춘선 제거."""

# 1~9호선 및 기타 전철·경전철 노선별로 직접 지정
speed_by_line = {
    '1호선': 28.6, '2호선': 36.5, '3호선': 34.9, '4호선': 30.1,
    '5호선': 32.8, '6호선': 30.0, '7호선': 32.3, '8호선': 32.2,
    '9호선': 26.2,
    '경의중앙선': 41.5, '수인분당선': 41.1,
    '신분당선': 54.9, '신림선': 26.5, '우이신설선': 28.7,
}

# 전역으로 이미 로드되어 있어야 할 것들:
#   road_graph  ──> OSMnx로 만든 도로망 그래프 (networkx.Graph or MultiDiGraph)
#   haversine   ──> (lat1, lon1, lat2, lon2) 간 거리(미터) 계산 함수
#   WALK_SPEED, WALK_PENALTY ──> 보행 속도(km/h), 환승 페널티(분) 등

def build_metro_graph(
    station_json: str,
    line_json: str,
    speed_by_line: dict
):
    """
    station_json: 지하철 역 정보 JSON 파일 경로
    line_json:    지하철 노선 연결 정보 JSON 파일 경로
    speed_by_line: { '1호선': 30.0, '2호선': 32.0, ... }처럼 호선별 평균 속도( km/h ) 딕셔너리

    - station_json의 각 원소 s는 최소한 {'station_cd','name','lat','lng'} 키를 가져야 합니다.
    - line_json의 각 원소 info는 {'line':호선명, 'node':[ {'station':[ {...}, {...} ]}, ... ]} 구조이어야 합니다.
    """
    # 1) JSON 데이터 로드
    stations = json.load(open(station_json, 'r', encoding='utf-8'))['DATA']
    lines    = json.load(open(line_json,    'r', encoding='utf-8'))['DATA']

    # JSON 로드 후, speed_by_line에 정의된 호선만 남긴다
    lines = [info for info in lines if info['line'] in speed_by_line]

    # 2) station_cd → {name, lat, lng} 사전 생성
    station_map = {
        s['station_cd']: {
            'name': s.get('name', s.get('station_nm')),
            'lat':  float(s['lat']),
            'lng':  float(s['lng'])
        }
        for s in stations
    }

    # 3) 남은 lines에 등장하는 station_cd만 사용하도록 필터링
    used_ids = {
        seg['station'][0]['station_cd']
        for info in lines
        for seg in info.get('node', [])
    } | {
        seg['station'][1]['station_cd']
        for info in lines
        for seg in info.get('node', [])
    }
    station_ids = list(used_ids)

    # 4) KDTree용 좌표 배열 생성 (사용자 좌표 → nearest 역 인덱스 용)
    coords_metro = np.array([
        [station_map[_id]['lat'], station_map[_id]['lng']]
        for _id in station_ids
    ])
    station_tree = cKDTree(coords_metro)

    # 5) 도로망 그래프 상의 노드 매핑: station_cd → nearest road_graph 노드 ID
    lats = [station_map[_id]['lat'] for _id in station_ids]
    lons = [station_map[_id]['lng'] for _id in station_ids]
    road_nodes = nearest_nodes(road_graph, lons, lats)
    station_to_road = dict(zip(station_ids, road_nodes))

    # 6) Graph 초기화
    Gm = nx.Graph()

    # 7) 호선별 인접역 엣지 추가
    for info in lines:
        line_name = info['line']
        speed_kmh = speed_by_line.get(line_name, 30.0)
        for seg in info.get('node', []):
            a_cd = seg['station'][0]['station_cd']
            b_cd = seg['station'][1]['station_cd']
            na = station_map[a_cd]
            nb = station_map[b_cd]
            u_node = f"{line_name}_{na['name']}"
            v_node = f"{line_name}_{nb['name']}"

            # 노드 추가
            if not Gm.has_node(u_node):
                Gm.add_node(u_node, station=na['name'], line=line_name, lat=na['lat'], lng=na['lng'])
            if not Gm.has_node(v_node):
                Gm.add_node(v_node, station=nb['name'], line=line_name, lat=nb['lat'], lng=nb['lng'])

            # 도로망 기반 거리 계산
            u_rg = station_to_road[a_cd]
            v_rg = station_to_road[b_cd]
            try:
                dist_m = nx.shortest_path_length(road_graph, u_rg, v_rg, weight='length')
            except Exception:
                dist_m = haversine(na['lat'], na['lng'], nb['lat'], nb['lng'])

            # 시간 weight 계산 (분)
            t_min = dist_m / 1000 / speed_kmh * 60
            Gm.add_edge(u_node, v_node, weight=t_min, mode='metro_edge')

    # 8) 환승 엣지 추가 (같은 station_cd에 따른 역 연결)
    st2nodes = defaultdict(list)
    for node, data in Gm.nodes(data=True):
        st2nodes[data['station']].append(node)

    for nodes_list in st2nodes.values():
        if len(nodes_list) < 2:
            continue
        for i in range(len(nodes_list)):
            for j in range(i+1, len(nodes_list)):
                u, v = nodes_list[i], nodes_list[j]
                lat_u, lng_u = Gm.nodes[u]['lat'], Gm.nodes[u]['lng']
                lat_v, lng_v = Gm.nodes[v]['lat'], Gm.nodes[v]['lng']
                walk_m = haversine(lat_u, lng_u, lat_v, lng_v)
                wt = walk_m / 1000 / WALK_SPEED * 60 + WALK_PENALTY
                Gm.add_edge(u, v, weight=wt, mode='transfer')
                Gm.add_edge(v, u, weight=wt, mode='transfer')

    return Gm, station_ids, station_tree

# 올바른 언패킹 예시
metro_graph, station_ids, station_tree = build_metro_graph(
    'metro_station.json',
    'metro_line.json',
    speed_by_line
)

print(f"지하철 그래프 노드 개수: {metro_graph.number_of_nodes()}")
print(f"지하철 그래프 엣지 개수: {metro_graph.number_of_edges()}")

# 1-1) 노드 정보 추출 & DataFrame 생성
nodes_data = [
    {
        'node_key': node,
        'station': data['station'],
        'line':    data['line'],
        'lat':     data['lat'],
        'lng':     data['lng']
    }
    for node, data in metro_graph.nodes(data=True)
]
metro_nodes_df = pd.DataFrame(nodes_data)
print(f"총 메트로 노드 수: {len(metro_nodes_df)}")
display(metro_nodes_df.head(10))

# 1-2) 엣지 정보 추출 & DataFrame 생성
edges_data = [
    {
        'from':       u,
        'to':         v,
        'mode':       data.get('mode'),
        'weight_min': data.get('weight')
    }
    for u, v, data in metro_graph.edges(data=True)
]
metro_edges_df = pd.DataFrame(edges_data)
print(f"총 메트로 엣지 수: {len(metro_edges_df)}")
display(metro_edges_df.head(10))

# 1-3) 특정 역 연결 확인 (예: '신당'역)
station_of_interest = '신당'
mask = metro_nodes_df['station'] == station_of_interest
nodes_of_interest = metro_nodes_df.loc[mask, 'node_key'].tolist()

print(f"\n'{station_of_interest}'역에 해당하는 그래프 노드들:", nodes_of_interest)
for nk in nodes_of_interest:
    nbrs = metro_graph[nk]
    print(f"  • {nk}와 연결된 노드:")
    for nbr, attr in nbrs.items():
        print(f"      - {nbr} (mode={attr['mode']}, {attr['weight']:.2f}분)")

def compute_bus_edge(task):
    """
    task: (u_idx, v_idx, lines_set)
    STOP_COORD, STOP_TO_ROAD, road_graph, AVG_SPEED_KMH_GLOBAL 전역 사용.

    # 버스 구간도 OSM 도로망 기반 최단경로로 계산하도록 변경
    """
    u_idx, v_idx, lines = task

    # 1) 허버사인 대신, ‘정류장 idx → 가장 가까운 도로망 노드’ 매핑 사용
    u_rg = STOP_TO_ROAD[u_idx]
    v_rg = STOP_TO_ROAD[v_idx]

    # 2) OSM 도로망에서 최단 경로 길이(미터) 구하기 (weight='length')
    try:
        dist_m = nx.shortest_path_length(road_graph, u_rg, v_rg, weight='length')
    except (nx.NetworkXNoPath, Exception):
        # 도로망 경로가 없으면 허버사인으로 fallback
        y1, x1 = STOP_COORD[u_idx]
        y2, x2 = STOP_COORD[v_idx]
        dist_m = haversine(y1, x1, y2, x2)

    # 3) 거리 → 버스 평균 속도(AVG_SPEED_KMH_GLOBAL)로 분 단위 환산
    t_min = dist_m / 1000 / AVG_SPEED_KMH_GLOBAL * 60
    return u_idx, v_idx, t_min, lines

def build_bus_graph_optimized(
    stops_excel: str,
    routes_excel: str,
    avg_speed_kmh: float = 18.0
):
    """
    1) stops_excel: 'bus_stops_seoul.xlsx' 경로 (컬럼: ['정류소명','X좌표','Y좌표'])
    2) routes_excel: 'bus_route.xlsx' 경로 (컬럼: ['노선명','정류소명','순번','X좌표','Y좌표'])
    3) avg_speed_kmh: 버스 평균 속도(km/h), 기본 18.0

    - 버스 정류장 간 좌표 매핑 → 잘못 매핑된(거리 차이 큰) 로우들은 자동으로 드롭
    - STOP_TO_ROAD: 각 정류장 인덱스를 OSM 도로망 노드 ID로 매핑하고,
      동일 도로망 노드에 매핑된 정류장이 몇 개 있는지(overlap)를 출력
    - 노드명 = f"{노선명}_{정류소명}"
    - 버스 이동 엣지 생성 (OSM 도로망 최단경로 이용)
    - 보행 환승 엣지 생성 (1,000m 이내, 20분 이내 걸어갈 수 있으면)
    - 반환값: (bus_graph, edge_lines)
      • bus_graph: networkx.Graph (nodes: 노선명_정류소명, edges: mode, weight)
      • edge_lines: { (u_node, v_node): set(노선명) }
    """

    global STOP_COORD, STOP_TO_ROAD, AVG_SPEED_KMH_GLOBAL
    AVG_SPEED_KMH_GLOBAL = avg_speed_kmh

    # ─────────────────────────────────────────────────────────────────────────
    # 1) 정류장 엑셀 불러오기 & KDTree 생성
    stops_df = pd.read_excel(stops_excel, dtype={'X좌표': float, 'Y좌표': float})
    required_cols = {'정류소명','X좌표','Y좌표'}
    if not required_cols.issubset(stops_df.columns):
        raise ValueError(f"stops_excel에 반드시 {required_cols} 컬럼이 있어야 합니다.")

    # 인덱스가 정류장 고유 ID 역할 (0, 1, 2, …)
    stops_df = stops_df.reset_index(drop=True)

    # (1-1) KDTree 생성: stops_df의 (위도, 경도) 배열
    coords_bus = stops_df[['Y좌표','X좌표']].to_numpy()  # shape=(N,2)
    stop_tree  = cKDTree(coords_bus)

    # ─────────────────────────────────────────────────────────────────────────
    # 2) 노선 정보 엑셀 불러오기 & 좌표 기반 매핑 → 잘못된 매핑(drop)
    routes_df = pd.read_excel(routes_excel, dtype={'X좌표': float, 'Y좌표': float})
    required_cols2 = {'버스번호','정류소명','순번','X좌표','Y좌표'}
    if not required_cols2.issubset(routes_df.columns):
        raise ValueError(f"routes_excel에 반드시 {required_cols2} 컬럼이 있어야 합니다.")

    # (2-1) routes_df 각 행의 (위도,경도)를 KDTree 로 쿼리 → nearest stops_df 인덱스 찾기
    route_coords = routes_df[['Y좌표','X좌표']].to_numpy()
    dists, nearest_idx = stop_tree.query(route_coords, k=1)
    routes_df['matched_stop_idx'] = nearest_idx.astype(int)
    routes_df['matched_dist_m'] = [
        haversine(lat1, lon1,
                  stops_df.loc[idx,'Y좌표'], stops_df.loc[idx,'X좌표'])
        for (lat1, lon1), idx in zip(route_coords, nearest_idx)
    ]

    # (2-2) 특정 거리 임계치 이상(여기서는 50m) 차이가 나는 경우 “잘못된 좌표”로 보고 드롭
    DROP_THRESHOLD_M = 50.0
    mask_good = routes_df['matched_dist_m'] <= DROP_THRESHOLD_M
        # ↓ 여기에 삽입 ↓
    # KDTree 매핑 거리가 50m 초과한 로우(드롭될 행) 미리 살펴보기
    unassigned = routes_df[~mask_good]
    print("=== KDTree 매핑 거리가 50m 초과하여 드롭될 예시 10개 ===")
    # Jupyter가 아니면 print()만 사용해도 무방합니다
    display(unassigned[['버스번호','정류소명','matched_dist_m']].head(10))
    print(f"총 드롭된 로우 수: {len(unassigned)}")
    # ↑ 여기까지 삽입 ↑
    num_dropped = (~mask_good).sum()
    if num_dropped > 0:
        print(f">>> **{num_dropped}개의 노선-정류장 로우는 KDTree 매핑 거리가 {DROP_THRESHOLD_M}m 초과하여 드롭됩니다.**")
    routes_df = routes_df[mask_good].copy()

    # ─────────────────────────────────────────────────────────────────────────
    # 3) 버스 그래프 초기화 & 노드 생성 준비
    bus_graph = nx.Graph()
    # edge_lines: “(u_node, v_node) → {노선명 set}”
    edge_lines = defaultdict(set)

    # STOP_COORD: 정류장 idx → (lat, lon)
    STOP_COORD = {
        idx: (row['Y좌표'], row['X좌표'])
        for idx, row in stops_df.iterrows()
    }

    # ─────────────────────────────────────────────────────────────────────────
    # 4) STOP_TO_ROAD (정류장 idx → OSM 도로망 노드 ID) 매핑
    #    (lon, lat) 순서로 nearest_nodes 호출
    lats = stops_df['Y좌표'].values
    lons = stops_df['X좌표'].values
    road_nodes = ox.distance.nearest_nodes(road_graph, lons, lats)
    STOP_TO_ROAD = dict(enumerate(road_nodes))

    # 4-1) 동일한 OSM 노드에 매핑된 정류장(들) 찾기 → overlap 체크
    inv = defaultdict(list)
    for stop_idx, rnode in STOP_TO_ROAD.items():
        inv[rnode].append(stop_idx)

    overlap_count = 0
    overlap_groups = []
    for rnode, idx_list in inv.items():
        if len(idx_list) > 1:
            overlap_groups.append(idx_list)
            overlap_count += len(idx_list)
    if overlap_count > 0:
        print(f">>> **OSM 노드 상에서 겹치는(같은 노드에 매핑된) 정류장 인덱스 총 {overlap_count}개**")
        print("   - 예시 겹침 그룹 (stop_idx 리스트):")
        for grp in overlap_groups:
            print(f"     → {grp}")

    # ─────────────────────────────────────────────────────────────────────────
    # 5) “노선명_정류소명” 노드 & 버스 엣지 생성
    #    → 각 노선별로 ‘순번’ 순으로 정차 정류장 인덱스를 정렬한 뒤 인접 쌍(u_idx, v_idx)에 대해 엣지 추가
    for line_name, grp in routes_df.groupby('버스번호'):
        grp_sorted = grp.sort_values('순번')
        prev_idx = None
        for _, row in grp_sorted.iterrows():
            cur_idx = int(row['matched_stop_idx'])
            stop_name = stops_df.loc[cur_idx, '정류소명']

            # 노드명: "노선명_정류소명"
            this_node = f"{line_name}_{stop_name}"

            # 실제 노드가 없으면 생성 (노드 속성: coord, stop_idx, 노선명)
            if not bus_graph.has_node(this_node):
                lat0, lon0 = STOP_COORD[cur_idx]
                bus_graph.add_node(
                    this_node,
                    coord     = (lat0, lon0),
                    stop_idx  = cur_idx,
                    route     = line_name
                )

            if prev_idx is not None and prev_idx != cur_idx:
                prev_stop_name = stops_df.loc[prev_idx, '정류소명']
                prev_node = f"{line_name}_{prev_stop_name}"

                # 5-1) 버스 구간 거리 계산 (OSM 도로망 경로 길이)
                u_rg = STOP_TO_ROAD[prev_idx]
                v_rg = STOP_TO_ROAD[cur_idx]
                try:
                    dist_m = nx.shortest_path_length(road_graph, u_rg, v_rg, weight='length')
                except (nx.NetworkXNoPath, Exception):
                    # 도로망 연결 없으면 직선거리 fallback
                    lat_u, lon_u = STOP_COORD[prev_idx]
                    lat_v, lon_v = STOP_COORD[cur_idx]
                    dist_m = haversine(lat_u, lon_u, lat_v, lon_v)

                # 5-2) 소요 시간 계산(분) = 거리(m) / 1000 / 속도(km/h) * 60
                t_min = dist_m / 1000 / AVG_SPEED_KMH_GLOBAL * 60

                # 5-3) 양방향 버스 엣지 추가
                bus_graph.add_edge(
                    prev_node, this_node,
                    weight = t_min,
                    mode   = 'bus_edge'
                )
                bus_graph.add_edge(
                    this_node, prev_node,
                    weight = t_min,
                    mode   = 'bus_edge'
                )

                # 5-4) edge_lines에 해당 엣지를 어떤 노선이 쓰는지 기록
                edge_lines[(prev_node, this_node)].add(line_name)
                edge_lines[(this_node, prev_node)].add(line_name)

            prev_idx = cur_idx

    # ─────────────────────────────────────────────────────────────────────────
    # 6) 보행 환승 엣지 추가 (1,000m 반경 / 20분 이내)
    TRANSFER_RADIUS_M = 1000.0
    # 반경(deg) 단순 변환 (위도 1° ≈ 111 km) → 대략적인 검색용
    radius_deg = TRANSFER_RADIUS_M / 111000.0

    # stop_tree는 1번에서 생성한 KDTree
    # coords_bus: (위도,경도) 배열
    for u_idx in range(len(stops_df)):
        # 이 정류장(u_idx) 반경 radius_deg 내 이웃 정류장 인덱스 리스트
        nbrs = stop_tree.query_ball_point(coords_bus[u_idx], r=radius_deg)
        for v_idx in nbrs:
            if v_idx <= u_idx:
                continue

            # 실제 직선 거리(미터)
            lat_u, lon_u = STOP_COORD[u_idx]
            lat_v, lon_v = STOP_COORD[v_idx]
            dist_uv = haversine(lat_u, lon_u, lat_v, lon_v)

            # “걸어서 걸리는 시간(분)”
            walk_time = dist_uv / 1000 / WALK_SPEED * 60

            if walk_time <= 20.0:  # 20분 이내(≒1km)라면 환승 가능
                # u_idx, v_idx에 해당하는 모든 “노선별 노드”를 서로 연결
                # (stop_idx → 어떤 route들이 쓰고 있는지 알아야 함)
                # 따라서 먼저 “이 정류장 u_idx를 쓰는 노드들”을 찾자
                u_nodes = [node for node, data in bus_graph.nodes(data=True)
                           if data.get('stop_idx') == u_idx]
                v_nodes = [node for node, data in bus_graph.nodes(data=True)
                           if data.get('stop_idx') == v_idx]

                for un in u_nodes:
                    for vn in v_nodes:
                        # 이미 버스 엣지가 있으면 skip (버스 엣지가 있으면 mode='bus_edge'이므로)
                        if bus_graph.has_edge(un, vn):
                            continue
                        # u→v 환승 엣지
                        bus_graph.add_edge(
                            un, vn,
                            weight = walk_time + WALK_PENALTY,
                            mode   = 'transfer'
                        )
                        # v→u 환승 엣지
                        bus_graph.add_edge(
                            vn, un,
                            weight = walk_time + WALK_PENALTY,
                            mode   = 'transfer'
                        )

    return bus_graph, edge_lines

# 4.3. build_bus_graph_optimized 함수 실행 및 결과 확인
bus_graph, edge_lines = build_bus_graph_optimized('bus_stops.xlsx', 'bus_route.xlsx', avg_speed_kmh=18.0)

print(f"최종 버스 그래프 노드(정류장) 개수: {bus_graph.number_of_nodes()}")
print(f"최종 버스 그래프 엣지(유니크) 개수: {bus_graph.number_of_edges()}")

# 예시: "bus_2840" 와 "bus_9421" 의 정류장 인덱스(idx) 가 각각 무엇인지 알아낸 뒤 그 값을 넣어서 테스트

# 1) 정류장 idx → road node ID 출력
print("=== STOP_TO_ROAD 샘플 매핑 확인 ===")
sample_indices = [  # 여기에는 실제 버스 노드 인덱스를 넣어주세요. 예제에서는 2840, 9421 가 아니라
                   # stops_df 에서 할당된 idx(0~n-1) 값이어야 합니다.
                   # 코드 전체에서 가장 먼저 'bus_2840' 처럼 쓰인 건 "bus_graph 노드 키"이지,
                   # STOP_TO_ROAD에서는 정수 idx 그대로를 사용했으니,
                   # stops_df 내부에서 '정류장ID'가 몇 번째 인덱스인지 찾아서 써야 합니다.
                   2840, 9421
                 ]
for idx in sample_indices:
    if idx in STOP_TO_ROAD:
        print(f"정류장 idx {idx} → road_node ID: {STOP_TO_ROAD[idx]}")
    else:
        print(f"정류장 idx {idx} 은 STOP_TO_ROAD에 없습니다.")

# 2) 만약 동일 ID가 찍히면, 두 정류장은 사실상 road_graph 상 같은 노드를 가리키고 있는 것
if len(sample_indices) == 2:
    u_rg = STOP_TO_ROAD.get(sample_indices[0])
    v_rg = STOP_TO_ROAD.get(sample_indices[1])
    print("두 정류장 road-node 동일 여부:", u_rg == v_rg)

import pandas as pd

# 2-1) 노드 정보 추출 & DataFrame 생성
nodes_data = [
    {
        'node_key': node,
        'stop_idx': data['stop_idx'],
        'route':    data['route'],
        'lat':      data['coord'][0],
        'lng':      data['coord'][1]
    }
    for node, data in bus_graph.nodes(data=True)
]
bus_nodes_df = pd.DataFrame(nodes_data)
print(f"총 버스 노드 수: {len(bus_nodes_df)}")
display(bus_nodes_df.head(10))

# 2-2) 엣지 정보 추출 & DataFrame 생성
edges_data = [
    {
        'from':       u,
        'to':         v,
        'mode':       data.get('mode'),
        'weight_min': data.get('weight')
    }
    for u, v, data in bus_graph.edges(data=True)
]
bus_edges_df = pd.DataFrame(edges_data)
print(f"총 버스 엣지 수: {len(bus_edges_df)}")
display(bus_edges_df.head(10))

# 2-3) 특정 정류장 연결 확인 (예: 6번째 행의 stop_idx)
stop_idx_of_interest = bus_nodes_df.loc[5, 'stop_idx']

# ① stop_idx로 해당하는 모든 node_key를 뽑아낸 뒤
nodes_of_interest = bus_nodes_df.loc[
    bus_nodes_df['stop_idx'] == stop_idx_of_interest, 'node_key'
].tolist()

print(f"정류장 idx={stop_idx_of_interest}에 해당하는 노드들:", nodes_of_interest)

# ② 실제 존재하는 node_key로 bus_graph 조회
for node_key in nodes_of_interest:
    print(f"\n— {node_key}의 연결 목록 —")
    for nbr, attr in bus_graph[node_key].items():
        print(f"  • {nbr} (mode={attr['mode']}, {attr['weight']:.2f}분)")

# --- 5.0. 사전 준비: 필요한 전역 변수 및 함수가 이미 정의되었다고 가정 ---
# - metro_graph: Step3에서 생성된 지하철 그래프
# - bus_graph:   Step4에서 생성된 버스 그래프
# - STOP_COORD:  { idx: (lat, lon) } (버스 정류장 인덱스 → 위/경도)
# - WALK_SPEED, WALK_PENALTY: 보행 속도(km/h), 환승 패널티(분)
# - haversine(lat1, lon1, lat2, lon2): 두 지점 간 거리(미터) 계산 함수

# 5.1. 통합 그래프 초기화
integrated_graph = nx.Graph()

# ─── 1. 지하철 노드·엣지 복사 ─────────────────────────────────────────
for node, data in metro_graph.nodes(data=True):
    integrated_graph.add_node(
        node,
        mode='metro',
        station=data.get('station'),
        line=data.get('line'),
        lat=data.get('lat'),
        lng=data.get('lng')
    )

for u, v, data in metro_graph.edges(data=True):
    w = data.get('weight')
    if data.get('mode') == 'transfer':
        integrated_graph.add_edge(u, v, weight=w, mode='transfer')
    else:
        integrated_graph.add_edge(u, v, weight=w, mode='metro_edge')

# ─── 2. 버스 노드·엣지 복사 ─────────────────────────────────────────
 # bus_graph 노드(key) 그대로 사용, 반드시 'route'까지 복사해야 합니다
for node, data in bus_graph.nodes(data=True):
    integrated_graph.add_node(
        node,
        mode     = 'bus',
        stop_idx = data['stop_idx'],
        route    = data['route'],
        lat      = data['coord'][0],
        lng      = data['coord'][1]
    )
for (u, v), lines in edge_lines.items():
    integrated_graph.add_edge(
        u, v,
        weight = bus_graph[u][v]['weight'],
        mode   = bus_graph[u][v].get('mode','bus_edge'),
        lines  = lines
    )

# ─── 3. 버스↔지하철 환승 엣지 추가 (1 000m 반경) ────────────────────────

# 3-1) 버스 정류장 좌표 배열 + KDTree 준비
# STOP_COORD: { stop_idx: (lat, lon) } 형태
bus_indices   = list(STOP_COORD.keys())
bus_coords    = np.array([STOP_COORD[s] for s in bus_indices])  # shape=(N_bus, 2) → [(lat,lon), ...]
bus_tree      = cKDTree(bus_coords)

# (위도 1° ≈ 111 km) 정도이므로, 1 000 m 반경을 위/경도 단위로 _대략_ 변환
TRANSFER_RADIUS_M = 1000.0
radius_deg = TRANSFER_RADIUS_M / 111000.0  # ≈ 0.009009°

# 3-2) 각 메트로 노드마다 주변 버스 정류장 후보 찾고, 실제 거리 재확인
for m_node, m_data in metro_graph.nodes(data=True):
    metro_lat, metro_lon = m_data['lat'], m_data['lng']
    # KDTree 에서는 (lat, lon) 순서로 쿼리
    # 반경(radius_deg) 내 후보 버스 정류장 인덱스 배열(idx_in_bus_coords_list)을 돌려준다
    idxs_in_bus_array = bus_tree.query_ball_point([metro_lat, metro_lon], r=radius_deg)

    # 실제 환승 가능한 버스 정류장만 골라서 엣지 추가
    for arr_i in idxs_in_bus_array:
        stop_idx = bus_indices[arr_i]           # STOP_COORD의 실제 stop_idx
        bus_lat, bus_lon = STOP_COORD[stop_idx]

        # 실제 거리를 haversine으로 계산
        dist_m = haversine(bus_lat, bus_lon, metro_lat, metro_lon)
        if dist_m <= TRANSFER_RADIUS_M:
            walk_time     = (dist_m / 1000.0) / WALK_SPEED * 60.0
            transfer_time = walk_time + WALK_PENALTY

            bus_node_key  = f"bus_{stop_idx}"
            integrated_graph.add_edge(
                bus_node_key, m_node,
                weight = transfer_time,
                mode   = 'transfer'
            )

# ─── 4. 결과 확인 ─────────────────────────────────────────────────
node_count     = integrated_graph.number_of_nodes()
edge_count     = integrated_graph.number_of_edges()
transfer_edges = [(u, v) for u, v, d in integrated_graph.edges(data=True) if d['mode'] == 'transfer']

print("통합 그래프 노드 개수:", node_count)
print("통합 그래프 엣지 개수:", edge_count)
print("버스↔지하철 환승 엣지 개수:", len(transfer_edges))

# 통합 그래프에서 버스/지하철 환승 엣지만 샘플 확인
count = 0
for u, v, data in integrated_graph.edges(data=True):
    if data.get('mode') == 'transfer':
        print(f"환승 엣지: {u} ↔ {v}, time={data['weight']:.2f}분")
        count += 1
        if count >= 10:
            break

import pandas as pd

# 3-1) 노드 정보 추출 & DataFrame 생성
nodes_data = []
for node, data in integrated_graph.nodes(data=True):
    mode = data.get('mode')      # 안전하게 가져오기
    rd = {
        'node_key': node,
        'mode':     mode,
        'lat':      data.get('lat'),
        'lng':      data.get('lng')
    }
    if mode == 'metro':
        rd['station'] = data.get('station')
        rd['line']    = data.get('line')
    elif mode == 'bus':
        rd['stop_idx']= data.get('stop_idx')
        rd['route']   = data.get('route')
    else:
        # mode가 없는(또는 다른) 노드라면 필요에 따라 처리
        rd['note'] = 'unknown mode'
    nodes_data.append(rd)

int_nodes_df = pd.DataFrame(nodes_data)
print(f"총 통합 노드 수: {len(int_nodes_df)}")
display(int_nodes_df.head(10))

"""############ 후보지 생성."""

# ——————————————————————————————
#  1) KD-Tree 생성: 위경도 기반 가까운 노드 탐색
# ——————————————————————————————

# (1-1) 위/경도 좌표가 있는 노드만 추출
valid_nodes = []
coords = []
for node, data in integrated_graph.nodes(data=True):
    lat, lng = data.get('lat'), data.get('lng')
    if lat is None or lng is None:
        continue
    valid_nodes.append(node)
    coords.append((lat, lng))

# (1-2) numpy 배열 & KDTree 생성
all_nodes  = valid_nodes
all_coords = np.array(coords)  # shape=(N, 2)
all_tree   = cKDTree(all_coords)

def nearby_multimodal_nodes(user_lat, user_lon, radius_m=1000):
    radius_deg = radius_m / 111000.0
    idxs = all_tree.query_ball_point([user_lat, user_lon], r=radius_deg)
    print(f"→ radius_deg={radius_deg:.5f}, found {len(idxs)} candidate indices")
    for i in idxs[:10]:
        print("   sample node:", all_nodes[i], "coord:", all_coords[i])
    results = []
    for i in idxs:
        node = all_nodes[i]
        lat2, lon2 = integrated_graph.nodes[node]['lat'], integrated_graph.nodes[node]['lng']
        t_min = walk_time_via_road(user_lat, user_lon, lat2, lon2)
        results.append((node, t_min))
    results.sort(key=lambda x: x[1])
    return results

# ——————————————————————————————
#  2) 도로망 기반 보행시간 계산
# ——————————————————————————————

def walk_time_via_road(lat1, lon1, lat2, lon2):
    """
    두 지점 간 도로망(shortest-path) 보행시간 계산 (분 단위)
    - 경로가 없으면 허버사인 거리로 fallback
    """
    try:
        # 도로망에서 가장 가까운 노드 매핑
        u = nearest_nodes(road_graph, lon1, lat1)
        v = nearest_nodes(road_graph, lon2, lat2)
        # 최단 경로 길이 (미터)
        dist_m = nx.shortest_path_length(road_graph, u, v, weight='length')
    except (nx.NetworkXNoPath, Exception):
        # 네트워크 연결 불가 시 허버사인 거리 사용
        dist_m = haversine(lat1, lon1, lat2, lon2)
    # 거리 → 시간(분) 환산
    return (dist_m / 1000.0) / WALK_SPEED * 60.0

# 1) 계절 계산 함수
# ——————————————————————————————
def get_current_season(now=None):
    """
    now.month를 기준으로 계절 반환
      3~5월   봄 ('spring')
      6~8월   여름 ('summer')
      9~11월  가을 ('fall')
      12,1,2월 겨울 ('winter')
    """
    if now is None:
        now = datetime.now()
    m = now.month
    if 3 <= m <= 5:
        return 'spring'
    if 6 <= m <= 8:
        return 'summer'
    if 9 <= m <= 11:
        return 'fall'
    return 'winter'

# 모드별 허용 계절(필요시 수정)
SEASON_SERVICE = {
    'metro': ['spring','summer','fall','winter'],
    'bus':   ['spring','summer','fall','winter']
}

# ──────────────────────────────────────────
# 2) 정교한 운행 시간 로직 함수
# ──────────────────────────────────────────

def is_metro_operating(now=None):
    if now is None:
        now = datetime.now().time()
    # 05:30 ≤ now < 24:00  또는  00:00 ≤ now < 00:30
    return (now >= time(5,30)) or (now < time(0,30))

from zoneinfo import ZoneInfo  # 파이썬 3.9+

def is_bus_operating(node, now=None):
    """
    일반버스: 05:30 <= now <= 23:59:59
    N-야간버스: 00:00 <= now < 05:30
    """
    if now is None:
        # 한국시간 기준으로 now
        now = datetime.now(ZoneInfo("Asia/Seoul")).time()

    # integrated_graph에 저장된 route 속성 가져오기
    raw = integrated_graph.nodes[node]['route']
    # raw가 str이면 [raw], 그 외(리스트 등)면 list(raw)
    lines = [raw] if isinstance(raw, str) else list(raw)

    # 일반버스 리스트, 야간버스 리스트
    general = [r for r in lines if not r.startswith('N')]
    night   = [r for r in lines if     r.startswith('N')]

    # 1) 일반버스 운행 여부
    if general and time(5,30) <= now <= time(23,59,59):
        return True
    # 2) 야간버스 운행 여부
    if night and time(0,0) <= now < time(5,30):
        return True

    return False

# ——————————————————————————————
# (B) bus_nodes: 'mode'=='bus' AND 'route' 속성이 있는 노드만
# ——————————————————————————————
bus_nodes = [
    n for n,d in integrated_graph.nodes(data=True)
    if d.get('mode')=='bus' and d.get('route') is not None
]

# 헬퍼: node에 걸리는 노선 리스트로 정리
def get_bus_lines(node):
    raw = integrated_graph.nodes[node].get('route') or []
    return [raw] if isinstance(raw, str) else list(raw)

# ——————————————————————————————
# (C) 일반버스 전용 노드 하나
# ——————————————————————————————
gen_node = next(
    n for n in bus_nodes
    if get_bus_lines(n)              # 노선 하나라도 있고
    and all(not r.startswith('N') for r in get_bus_lines(n))  # 모두 일반
)

# ——————————————————————————————
# (D) N-야간버스 전용 노드 하나
# ——————————————————————————————
night_node = next(
    n for n in bus_nodes
    if get_bus_lines(n)
    and all(r.startswith('N') for r in get_bus_lines(n))  # 모두 N-야간
)

# ——————————————————————————————
# (E) 테스트 출력
# ——————————————————————————————
test_times = [
    time(0,0),  time(0,30), time(2,0),
    time(4,0),  time(5,0),  time(5,30),
    time(10,0), time(23,0), time(13,30)
]

print("Time  | Metro | GenBus | NightBus")
for t in test_times:
    m = '●' if is_metro_operating(t) else '×'
    g = '●' if is_bus_operating(gen_node, t) else '×'
    x = '●' if is_bus_operating(night_node, t) else '×'
    print(f"{t:%H:%M} |   {m}   |    {g}   |     {x}")

def filter_candidates_by_availability(candidates, now=None):
    """
    - candidates: [(node_key, walk_min), …]
    - 반환: 현재 계절·운행 중인 모드만 필터링
    """
    if now is None:
        now = datetime.now().time()
    season = get_current_season()

    print(f"\n[필터 시작] season={season}, now={now:%H:%M:%S}, 후보 수={len(candidates)}")
    valid = []
    for node, walk in candidates:
        mode = integrated_graph.nodes[node].get('mode')
        # 1) 계절 허용 여부
        if season not in SEASON_SERVICE.get(mode, []):
            print(f"  ✗ {node}({mode}) — 계절 불허 ({season})")
            continue

        # 2) 시간대별 운행 여부
        if mode == 'metro':
            ok = is_metro_operating(now)
            print(f"  {'●' if ok else '✗'} {node}(metro) — is_metro_operating? {ok}")
            if not ok:
                continue

        elif mode == 'bus':
            ok = is_bus_operating(node, now)
            print(f"  {'●' if ok else '✗'} {node}(bus)   — is_bus_operating? {ok}")
            if not ok:
                continue

        else:
            # mode 잘못 들어갔을 경우
            print(f"  ⚠ {node} — 알 수 없는 mode={mode}")
            continue

        # 여기까지 통과한 후보만 valid에 추가
        valid.append((node, walk))

    print(f"[필터 완료] 살아남은 후보 수={len(valid)}\n")
    return valid

# (1) 현재 시각
from datetime import datetime, timedelta

# UTC 기준 +9시간
now = (datetime.utcnow() + timedelta(hours=9)).time()


# (2) KDTree → 도로망 보행시간 계산으로 후보지 생성
start_candidates = nearby_multimodal_nodes(start_lat, start_lon,  radius_m=1000)
end_candidates   = nearby_multimodal_nodes(end_lat,   end_lon,    radius_m=1000)

# (3) 운행·계절 필터 적용
start_candidates = filter_candidates_by_availability(start_candidates, now)
end_candidates   = filter_candidates_by_availability(end_candidates,   now)

# (4) 결과 확인
print("출발 후보 (운행·계절 필터, 상위 10):", start_candidates[:10])
print("도착 후보 (운행·계절 필터, 상위 10):", end_candidates[:10])

def dedup_bus_only(candidates):
    """
    • metro 노드는 전부 유지
    • bus  노드는 같은 route·end_stop(탑승 후 첫 비-bus 모드에 도달하는 정류장) 시그니처 중
      보행 시간이 가장 짧은 하나만 남김
    """
    kept = []
    seen_bus = {}   # key: (route, end_stop) → value: (node, walk)

    for node, walk in candidates:
        data = integrated_graph.nodes[node]
        mode = data.get('mode')

        if mode == 'bus':
            route = data.get('route')

            # 1) 이 버스 노드를 타고 쭉 따라가 첫 환승·종착 지점(end_stop) 찾기
            current = node
            while True:
                # 현재 정류장에서 bus_edge만 골라 다음 정류장으로 이동
                bus_edges = [
                    nbr for nbr in integrated_graph.neighbors(current)
                    if integrated_graph[current][nbr].get('mode') == 'bus'
                ]
                if not bus_edges:
                    break
                # 편의상 첫 번째 bus_edge 따라감
                current = bus_edges[0]
                # 더 이상 bus 모드가 아니면 그게 end_stop
                if integrated_graph.nodes[current].get('mode') != 'bus':
                    break
            end_stop = current

            key = (route, end_stop)
            # 2) 같은 (route, end_stop) 중 보행시간 최소인 것만 저장
            if key not in seen_bus or walk < seen_bus[key][1]:
                seen_bus[key] = (node, walk)

        else:
            # metro 노드는 무조건 유지
            kept.append((node, walk))

    # 최종 후보: metro + dedup된 bus
    kept.extend(seen_bus.values())
    return kept

start_candidates = dedup_bus_only(start_candidates)
end_candidates   = dedup_bus_only(end_candidates)

# (중복 제거된 최종 후보 확인)
print("\n▶ Dedup된 출발 후보:", start_candidates)
print("▶ Dedup된 도착 후보:",   end_candidates)

"""# 최단시간 함수."""

def get_fastest_routes_optimized(G, origin_candidates, dest_candidates,
                                 k=10, max_transfers=4):
    """
    G: 통합 그래프 (metro+bus+transfer)
    origin_candidates: [(origin_node, origin_walk_min), …]
    dest_candidates:   [(dest_node,   dest_walk_min),   …]
    k: 상위 k개 결과 반환
    max_transfers: 허용할 최대 환승 횟수
    """
    fastest_list = []

    for origin_node, origin_walk in origin_candidates:
        # 1) 한 번만 Dijkstra
        distances, paths = nx.single_source_dijkstra(
            G, origin_node, weight='weight'
        )

        for dest_node, dest_walk in dest_candidates:
            if dest_node not in distances:
                continue

            path        = paths[dest_node]
            travel_time = distances[dest_node]
            total_time  = travel_time + origin_walk + dest_walk

            # ——— 시작/끝 “transfer” 엣지 제외 ———
            if len(path) >= 2:
                # 시작
                if G[path[0]][path[1]].get('mode') == 'transfer':
                    continue
                # 끝
                if G[path[-2]][path[-1]].get('mode') == 'transfer':
                    continue

            # 2) 환승 횟수 계산
            transfer_count = 0
            prev_mode, prev_line = None, None
            edges = list(zip(path, path[1:]))

            for idx, (u, v) in enumerate(edges):
                m = G[u][v].get('mode')
                # 중간 환승 엣지
                if m == 'transfer':
                    if 0 < idx < len(edges)-1:
                        transfer_count += 1
                    prev_mode, prev_line = 'transfer', None
                    continue
                # metro_edge: 호선 변경 시
                if m == 'metro_edge':
                    cur_line = G.nodes[u]['line']
                    if prev_mode=='metro_edge' and prev_line!=cur_line:
                        transfer_count += 1
                    prev_mode, prev_line = 'metro_edge', cur_line
                    continue
                # bus_edge: 노선 변경 시
                if m == 'bus_edge':
                    cur_route = next(iter(G[u][v].get('lines', [])), None)
                    if prev_mode=='bus_edge' and prev_line!=cur_route:
                        transfer_count += 1
                    prev_mode, prev_line = 'bus_edge', cur_route
                    continue
                prev_mode, prev_line = m, None

            # 3) 환승 제한
            if transfer_count > max_transfers:
                continue

            fastest_list.append({
                'path':      path,
                'time_min':  total_time,
                'transfers': transfer_count,
                'walk_min':  origin_walk + dest_walk
            })

    # 상위 k개만
    fastest_list.sort(key=lambda x: x['time_min'])
    return fastest_list[:k]

"""출발지, 도착지 관련 문제가 아직 남아있음."""

# 6) 최단 시간 경로 뽑기
routes = get_fastest_routes_optimized(
    integrated_graph,
    start_candidates,
    end_candidates,
    k=20,
    max_transfers=4
)

# 7) 결과 출력
for i, r in enumerate(routes, 1):
    print(f"\n{i}위: 총시간={r['time_min']:.1f}분 "
          f"(보행={r['walk_min']:.1f}분, 환승={r['transfers']}회)")
    print("  →", " → ".join(r['path']))

"""# 환승편의성"""

# 0. Colab 파일 업로드 (한 번만 필요)
uploaded = files.upload()

import json
import re
import pandas as pd
import numpy as np
import networkx as nx
from geopy.distance import geodesic
from itertools import islice

# —————————————————————————
# 1) 데이터 로드 & 매핑표 생성
# —————————————————————————

# 1.1) 환승보행시간 데이터 로드
df_tt = pd.read_json('metro_transfer_time .json')
df_tt = (
    df_tt
    .rename(columns={
        '호선':'line',
        '환승역명':'station',
        '환승노선':'transfer_line',
        '환승소요시간':'duration_str'
    })
    # '1호선' 형태로 맞추고 "MM:SS" → 분 단위 float
    .assign(
        line=lambda df: df['line'].astype(str)+'호선',
        duration_min=lambda df: df['duration_str']
            .str.split(':')
            .apply(lambda t: int(t[0]) + int(t[1])/60)
    )
)
transfer_time_map = {
    (row.line, row.transfer_line, row.station): row.duration_min
    for _, row in df_tt.iterrows()
}

# 1.2) 지하철 내부 정보 로드 (에스컬레이터 길이)
with open('metro_inside.json','r',encoding='utf-8') as f:
    df_ins = pd.DataFrame(json.load(f))
# 괄호 제거된 역명 컬럼 추가
df_ins['station_clean'] = df_ins['station_name'].str.replace(r'\(.*\)$','',regex=True)
es_map = {
    (row['lines'], row['station_clean']): row['escalator_optimal_length']
    for _, row in df_ins.iterrows()
}

# 1.2.3) 지면 고도 맵: (호선, 역명) → ground_elevation (m)
ge_map = {
    (row['lines'], row['station_clean']): row['ground_elevation']
    for _, row in df_ins.iterrows()
}

# 보행·에스컬레이터 속도 정의 (m/min)
WALK_SPEED = 4000 / 60   # 4km/h → 약 66.7 m/min
ES_SPEED   = 8000 / 60   # 8km/h → 약133.3 m/min

def calc_escalator_time(line, station, es_map):
    """
    에스컬레이터 길이 기반 환승 시간(분)
    """
    es_len = es_map.get((line, station), 0)
    if es_len > 0:
        return es_len / ES_SPEED  # 분 단위
    return 0

def calc_transfer_walk_time(path, G, transfer_time_map, es_map):
    """
    경로 내 지하철 환승 엣지마다 환승 소요시간 또는 에스컬레이터 환승시간 적용
    """
    transfer_time_sum = 0
    edges = list(zip(path, path[1:]))
    for idx, (u, v) in enumerate(edges):
        attr = G[u][v]
        if attr.get('mode') == 'transfer':
            # 지하철-지하철 환승인지 체크
            u_mode, v_mode = G.nodes[u].get('mode'), G.nodes[v].get('mode')
            u_line, v_line = G.nodes[u].get('line'), G.nodes[v].get('line')
            u_station, v_station = G.nodes[u].get('station'), G.nodes[v].get('station')

            # 둘 다 지하철 & 호선 다르면 환승
            if u_mode=='metro' and v_mode=='metro' and u_line!=v_line:
                # transfer_time_map에서 환승시간 있으면
                key = (u_line, v_line, u_station)
                t = transfer_time_map.get(key)
                if t is None:
                    # 반대 방향도 체크
                    key_rev = (v_line, u_line, v_station)
                    t = transfer_time_map.get(key_rev)
                if t is not None:
                    transfer_time_sum += t
                else:
                    # 환승 소요시간 정보 없으면 에스컬레이터 길이 사용
                    t_es = calc_escalator_time(u_line, u_station, es_map)
                    transfer_time_sum += t_es
    return transfer_time_sum

def calc_transfer_convenience(route, origin_walk, dest_walk, G, transfer_time_map, es_map):
    """
    route: path 리스트
    origin_walk, dest_walk: 출발·도착지 보행시간(분)
    G: 통합그래프
    transfer_time_map, es_map: 위에서 만든 매핑
    ---
    반환: 환승편의성 점수(환승횟수*2 + 전체 도보시간)
    """

    # 1) 경로 내 환승횟수 계산 (이전 코드 참고)
    transfer_count = 0
    prev_mode, prev_line = None, None
    edges = list(zip(route, route[1:]))

    for idx, (u, v) in enumerate(edges):
        m = G[u][v].get('mode')
        if m == 'transfer':
            if 0 < idx < len(edges)-1:
                transfer_count += 1
            prev_mode, prev_line = 'transfer', None
            continue
        if m == 'metro_edge':
            cur_line = G.nodes[u]['line']
            if prev_mode=='metro_edge' and prev_line!=cur_line:
                transfer_count += 1
            prev_mode, prev_line = 'metro_edge', cur_line
            continue
        prev_mode, prev_line = m, None

    # 2) 경로 내 환승 엣지의 '실제 보행시간(=환승보행+에스컬레이터 등)' 합산
    transfer_walk = calc_transfer_walk_time(route, G, transfer_time_map, es_map)

    # 3) 전체 도보시간 = 출발보행 + 도착보행 + (환승 엣지의 보행)
    total_walk = origin_walk + dest_walk + transfer_walk

    # 4) 최종 환승편의성 점수
    score = transfer_count*2 + total_walk
    return score, transfer_count, total_walk

def get_best_transfer_routes(G, origin_candidates, dest_candidates, transfer_time_map, es_map, k=10, max_transfers=4):
    results = []

    for origin_node, origin_walk in origin_candidates:
        distances, paths = nx.single_source_dijkstra(G, origin_node, weight='weight')
        for dest_node, dest_walk in dest_candidates:
            if dest_node not in distances:
                continue
            route = paths[dest_node]
            score, transfer_count, total_walk = calc_transfer_convenience(
                route, origin_walk, dest_walk, G, transfer_time_map, es_map
            )
            if transfer_count > max_transfers:
                continue
            results.append({
                'path': route,
                'score': score,
                'transfers': transfer_count,
                'walk_min': total_walk
            })

    results.sort(key=lambda x: x['score'])
    return results[:k]

routes = get_best_transfer_routes(
    integrated_graph, start_candidates, end_candidates,
    transfer_time_map, es_map,
    k=10, max_transfers=4
)
for i, r in enumerate(routes, 1):
    print(f"\n[{i}] 환승편의성={r['score']:.1f} (환승={r['transfers']}회, 도보={r['walk_min']:.1f}분)")
    print("  경로:", " → ".join(r['path']))

# 0. Colab 파일 업로드 (한 번만 필요)
uploaded = files.upload()

"""#정시성 함수 만들기.
- 사고는 최근 5년, 늦은건 1년 기준
- 클수록 안좋음.
"""

for node, data in bus_graph.nodes(data=True):
    integrated_graph.add_node(
        node,
        node_key = node,       # <- 무조건 추가
        mode     = 'bus',
        stop_idx = data['stop_idx'],
        route    = data['route'],
        lat      = data['coord'][0],
        lng      = data['coord'][1]
    )

for node in integrated_graph.nodes:
    data = integrated_graph.nodes[node]
    if data.get('mode') == 'bus' and 'node_key' not in data:
        print('!!! node_key 없음:', node, data)

import pandas as pd
import json

# 엑셀 파일
df_bus_late = pd.read_excel('bus_late.xlsx')
df_bus_acc = pd.read_excel('bus_accident.xlsx')
df_metro_late = pd.read_excel('metro_late.xlsx')
with open('metro_accident.json', encoding='utf-8') as f:
    metro_accidents = {row['역명']: row['사고횟수'] for row in json.load(f)}

for df in [df_bus_late, df_bus_acc]:
    if '정류소명' in df.columns:
        df['정류소명'] = df['정류소명'].str.replace('\ufeff', '', regex=False)

bus_stops_df = pd.read_excel('bus_stops.xlsx')

# bus_stops.xlsx 또는 해당 DataFrame에서
# 실제 컬럼명은 'NODE_ID', 'ARS_ID', '정류소명', 'X좌표', 'Y좌표'
STOP_IDX_TO_NAME = dict(zip(bus_stops_df['NODE_ID'], bus_stops_df['정류소명']))

# ========== 1. 지하철 사고 매핑 ==========
def get_metro_accident_prob(station):
    cnt = metro_accidents.get(station, 0)
    return cnt / (5*365)

# ========== 2. 지하철 지연 매핑 ==========
df_metro_late = pd.read_excel('metro_late.xlsx')
# 예시: 컬럼 ['계절','호선','역명','평균지연시간','지연건수','전체운행일수' ...]
def get_metro_late(station, line, season):
    rows = df_metro_late[(df_metro_late['line'] == line) & (df_metro_late['season'] == season)]
    if not rows.empty:
        delay_time = float(rows['지연시간'].values[0])
        delay_prob = 1.0  # 확률 정보 없으니 1로 가정
        return delay_time, delay_prob
    else:
        return 0, 0

# ========== 3. 버스 사고 매핑 ==========
def clean_stop_name(s):
    # 공백, 온점, 괄호, 특수문자 등 전처리 (필요에 따라 수정)
    return str(s).replace('\ufeff','').replace(' ','').replace('.', '').replace('·','').replace('(','').replace(')','').strip()
def clean_route_num(s):
    return str(s).replace('\ufeff', '').strip()

def get_bus_accident_prob(data):
    node_key = data.get('node_key')
    route = data.get('route')
    if not node_key or not route:
        print(f"[WARN] node_key or route missing: {data}")
        return 0

    stop_name = node_key.split("_", 1)[1]
    stop_name_clean = clean_stop_name(stop_name)
    route_clean = clean_route_num(route)

    # 클린 컬럼 미리 생성
    if '버스번호_clean' not in df_bus_acc.columns:
        df_bus_acc['버스번호_clean'] = df_bus_acc['버스번호'].map(clean_route_num)
    if '정류소명' in df_bus_acc.columns:
        if '정류소명_clean' not in df_bus_acc.columns:
            df_bus_acc['정류소명_clean'] = df_bus_acc['정류소명'].map(clean_stop_name)
        # 정류소명 + 버스번호로 매칭
        row = df_bus_acc[
            (df_bus_acc['정류소명_clean'] == stop_name_clean) &
            (df_bus_acc['버스번호_clean'] == route_clean)
        ]
        cnt = int(row['사고횟수'].values[0]) if not row.empty else 0
    else:
        # 버스번호로만 매칭
        row = df_bus_acc[df_bus_acc['버스번호_clean'] == route_clean]
        cnt = int(row['사고횟수'].values[0]) if not row.empty else 0

    return cnt / (5*365)

def get_bus_late(data):
    node_key = data.get('node_key')
    route = str(data.get('route'))
    if not node_key or not route:
        print(f"[WARN] node_key or route missing: {data}")
        return 0, 0

    def clean_stop_name(s):
        return s.replace(' ','').replace('.', '').replace('·','').replace('(', '').replace(')','').replace('-', '').strip()
    def clean_route_num(s):
        return str(s).replace('\ufeff', '').strip()

    stop_name = node_key.split("_", 1)[1]
    stop_name_clean = clean_stop_name(stop_name)
    route_clean = clean_route_num(route)

    if '정류소명_clean' not in df_bus_late.columns:
        df_bus_late['정류소명_clean'] = df_bus_late['정류소명'].map(clean_stop_name)
    if '버스번호_clean' not in df_bus_late.columns:
        df_bus_late['버스번호_clean'] = df_bus_late['버스번호'].map(clean_route_num)

    row = df_bus_late[
        (df_bus_late['정류소명_clean'] == stop_name_clean) &
        (df_bus_late['버스번호_clean'] == route_clean)
    ]
    if row.empty:
        print(f"[WARN] No bus_late match: stop_name={stop_name_clean}, route={route_clean}")
        return 0, 0

    n1 = int(str(row['평균2분이하건수'].values[0]).replace('\ufeff', '').strip())
    n2 = int(str(row['평균2분초과건수'].values[0]).replace('\ufeff', '').strip())
    tot = n1 + n2 if (n1 + n2) > 0 else 1
    delay_prob = n2 / tot
    if n2 >= 3 * n1:
        t = 2.7
    elif n2 >= 2 * n1:
        t = 2.3
    elif n2 >= n1:
        t = 2.0
    else:
        t = 3.0
    return t, delay_prob

def calc_route_punctuality(route, G, season):
    total_score = 0
    for node in route:
        data = G.nodes[node]
        mode = data.get('mode')
        if mode == 'metro':
            line = data.get('line')
            station = data.get('station')
            delay_t, delay_p = get_metro_late(station, line, season)
            accident_p = get_metro_accident_prob(station)
            punctuality_score = (delay_p * delay_t) + accident_p
        elif mode == 'bus':
            t, p = get_bus_late(data)
            accident_p = get_bus_accident_prob(data)
            punctuality_score = (p * t) + accident_p
        else:
            punctuality_score = 0
        total_score += punctuality_score
    return total_score

def get_best_punctuality_routes(G, origin_candidates, dest_candidates, season, k=10, max_transfers=4):
    results = []
    for origin_node, origin_walk in origin_candidates:
        distances, paths = nx.single_source_dijkstra(G, origin_node, weight='weight')
        for dest_node, dest_walk in dest_candidates:
            if dest_node not in distances:
                continue
            route = paths[dest_node]
            # 환승 횟수 계산(생략 가능, 기존 코드 참고)
            transfer_count = 0
            prev_mode, prev_line = None, None
            edges = list(zip(route, route[1:]))
            for idx, (u, v) in enumerate(edges):
                m = G[u][v].get('mode')
                if m == 'transfer':
                    if 0 < idx < len(edges)-1:
                        transfer_count += 1
                    prev_mode, prev_line = 'transfer', None
                    continue
                if m == 'metro_edge':
                    cur_line = G.nodes[u].get('line')
                    if prev_mode == 'metro_edge' and prev_line != cur_line:
                        transfer_count += 1
                    prev_mode, prev_line = 'metro_edge', cur_line
                    continue
                if m == 'bus_edge':
                    cur_route = G.nodes[u].get('route')
                    if prev_mode == 'bus_edge' and prev_line != cur_route:
                        transfer_count += 1
                    prev_mode, prev_line = 'bus_edge', cur_route
                    continue
                prev_mode, prev_line = m, None
            if transfer_count > max_transfers:
                continue

            punctuality_score = calc_route_punctuality(route, G, season)
            results.append({
                'path': route,
                'score': punctuality_score,
                'transfers': transfer_count,
                'walk_min': origin_walk + dest_walk
            })
    results.sort(key=lambda x: x['score'])
    return results[:k]

season = 'spring'
routes = get_best_punctuality_routes(
    integrated_graph, start_candidates, end_candidates, season,
    k=10, max_transfers=4
)
for i, r in enumerate(routes, 1):
    print(f"\n[{i}] 정시성점수={r['score']:.5f} (환승={r['transfers']}회, 도보={r['walk_min']:.1f}분)")
    print("  경로:", " → ".join(r['path']))

"""# 쾌적도 함수"""

# 0) 쾌적 점수 매핑 함수 정의 (반드시 이 셀 맨 위에 위치)
def score_microdust_cat(x):
    if x <= 30:
        return 4
    elif x <= 80:
        return 3
    elif x <= 150:
        return 2
    else:
        return 1

def score_temp_cat(x):
    if 10 <= x <= 24:
        return 4
    elif (0 <= x < 10) or (24 < x <= 28):
        return 3
    elif (-10 <= x < 0) or (28 < x <= 34):
        return 2
    else:
        return 1

def score_humidity_cat(h):
    if 50 <= h <= 60:
        return 4
    elif 40 <= h < 50:
        return 3
    elif h < 40:
        return 2
    else:
        return 1

import pandas as pd
import numpy as np
from scipy.spatial import cKDTree

# —— 1) 계절 가져오기 ————————————————————————————————
current_season = get_current_season()  # 'spring','summer','fall','winter'

# —— 2) 환경 지표 로드 & 필터링 ——————————————————————————
# metro_dust.xlsx: ['name','line','미세먼지','계절']
dust_df   = pd.read_excel('metro_dust.xlsx', dtype={'name':str, 'line':str, '미세먼지':float, '계절':str})
dust_season = dust_df[dust_df['season'] == current_season].copy()

# weather.xlsx: ['지역','season','avg_humidity','avg_temp','lng','lat','평균미세먼지']
weather_df = pd.read_excel(
    'weather.xlsx',
    dtype={'season': str},
    converters={
        'avg_temp':      lambda x: float(str(x).lstrip('\ufeff')),
        'avg_humidity':  lambda x: float(str(x).lstrip('\ufeff')),
        'lat':           lambda x: float(str(x).lstrip('\ufeff')),
        'lng':           lambda x: float(str(x).lstrip('\ufeff'))
    }
)


weather_season = weather_df[weather_df['season'] == current_season].copy()

# —— 3) 매핑 테이블 & KDTree 준비 ————————————————————————
# 3-1) dust_map: station_name → score(1~4)
dust_season['dust_score'] = dust_season['미세먼지'].apply(score_microdust_cat)
dust_map = dict(zip(dust_season['name'], dust_season['dust_score']))

# 3-2) weather KDTree: (lat,lng) → (temp_score, humidity_score)
weather_season['temp_score']     = weather_season['avg_temp'].apply(score_temp_cat)
weather_season['humid_score']    = weather_season['avg_humidity'].apply(score_humidity_cat)
coords_weather = weather_season[['lat','lng']].to_numpy()
weather_tree   = cKDTree(coords_weather)
weather_records = weather_season.reset_index(drop=True)

weather_records

def get_weather_scores(lat, lng):
    """가장 가까운 weather 레코드 찾아서 (temp_score, humid_score) 반환"""
    _, idx = weather_tree.query([lat, lng])
    rec = weather_records.loc[idx]
    return rec['temp_score'], rec['humid_score']

# —— 4) 구간별 쾌적 점수 함수 —————————————————————————
def edge_comfort(u, v, G):
    mode = G[u][v].get('mode')
    if mode == 'metro_edge':
        st     = G.nodes[u]['station']
        y, x   = G.nodes[u]['lat'], G.nodes[u]['lng']
        # ① 미세먼지 점수
        d_score = dust_map.get(st, 2)
        # ② 날씨 점수
        t_score, h_score = get_weather_scores(y, x)
        # ③ 평균 내리기
        return np.mean([d_score, t_score, h_score])
    elif mode == 'transfer':
        # 환승은 페널티(낮은 쾌적도)
        return 1.0
    else:
        # bus_edge 혹은 기타 구간: 기본 중간값
        return 2.0

# —— 5) 경로 쾌적도 평가 함수 ———————————————————————
def evaluate_route_pleasant(path, G):
    scores = [edge_comfort(u, v, G) for u, v in zip(path, path[1:])]
    return np.mean(scores)

# —— 6) 최적 쾌적 경로 추천 ———————————————————————
def find_most_pleasant_routes(G, origin_cand, dest_cand, k=5, max_transfers=4):
    # (1) 시간 기준 상위 N개 경로 우선 뽑기
    time_routes = get_fastest_routes_optimized(G, origin_cand, dest_cand,
                                              k=50, max_transfers=max_transfers)
    # (2) 각 경로에 쾌적 점수 매핑
    for r in time_routes:
        r['pleasant_score'] = evaluate_route_pleasant(r['path'], G)
    # (3) 쾌적 점수 내림차순 정렬 (높을수록 더 쾌적)
    pleasant = sorted(time_routes,
                      key=lambda x: x['pleasant_score'],
                      reverse=True)
    return pleasant[:k]

# —— 7) 사용 예시 ——————————————————————————————
pleasant_routes = find_most_pleasant_routes(
    integrated_graph, start_candidates, end_candidates, k=3
)

for i, r in enumerate(pleasant_routes, 1):
    print(f"\n[{i}위] 쾌적점수={r['pleasant_score']:.2f}, "
          f"총시간={r['time_min']:.1f}분 (보행={r['walk_min']:.1f}분, 환승={r['transfers']}회)")
    print("경로:", " → ".join(r['path']))

"""고려..."""

# 2) 불쾌지수 계산 함수 정의
def discomfort_index(temp_c, hum_pct):
    """
    불쾌지수 계산 공식:
      DI = 0.81*T + 0.01*RH*(0.99*T - 14.3) + 46.3
      T: 온도(°C), RH: 상대습도(%)
    """
    return 0.81 * temp_c + 0.01 * hum_pct * (0.99 * temp_c - 14.3) + 46.3

def score_di_cat(di):
    # 불쾌지수에 대해 온도 기준 점수를 재사용
    return score_temp_cat(di)

"""# 혼잡도 함수"""

import pandas as pd

# 파일 경로 재지정 (리셋됨)
metro_confuse_path = "metro_confuse.xlsx"
bus_confuse_path = "bus_confuse.csv"
bus_speed_path = "bus_confuse_speed.xlsx"

# 파일 읽기
df_metro = pd.read_excel(metro_confuse_path)
df_bus = pd.read_csv(bus_confuse_path)
df_speed = pd.read_excel(bus_speed_path)

# -------------------------------
# 2. 유틸 함수 정의
# -------------------------------

def clean_station_name(raw):
    """(가상)(00000) 제거 및 정류소명 정제"""
    return re.sub(r"\(.*?\)", "", str(raw)).strip()

def parse_node(node_name):
    """노드명 → {'mode': 'bus'/'metro', 'line': '3호선', 'station': '종로3가'}"""
    if "_" not in node_name:
        return None
    parts = node_name.split("_")
    line = parts[0]
    station = "_".join(parts[1:])
    mode = "metro" if "호선" in line else "bus"
    return {"mode": mode, "line": line, "station": station}

def get_current_time_info(now=None):
    """현재 시각 → 시간대, 요일구분, 계절 반환"""
    if now is None:
        now = datetime.now(ZoneInfo("Asia/Seoul"))
    hour = now.hour
    weekday = now.weekday()
    if weekday < 5:
        day_type = "평일"
    elif weekday == 5:
        day_type = "토요일"
    else:
        day_type = "일요일"

    month = now.month
    if 3 <= month <= 5:
        season = "spring"
    elif 6 <= month <= 8:
        season = "summer"
    elif 9 <= month <= 11:
        season = "fall"
    else:
        season = "winter"

    return hour, day_type, season

# 데이터 확인용 샘플 출력
sample_metro = df_metro.head(2)
sample_bus = df_bus.head(2)
sample_speed = df_speed.head(2)

# -------------------------------
# 3. 혼잡도 계산 함수 정의
# -------------------------------

def get_metro_congestion(line, station, hour, day_type):
    """지하철 혼잡도 계산"""
    time_str = f"{hour:02d}시00분"  # e.g., "08시00분"
    subset = df_metro[
        (df_metro["호선"].astype(str) == str(line).replace("호선", "")) &
        (df_metro["출발역"] == station) &
        (df_metro["요일구분"] == day_type)
    ]
    if not subset.empty and time_str in subset.columns:
        return subset[time_str].mean() / 100  # 100명 기준 혼잡도 (비율로 반환)
    return 0.0

def get_bus_congestion(route, station, season, hour):
    """버스 혼잡도 계산"""
    station_clean = clean_station_name(station)
    time_col = f"{hour}시총승객수"
    matched = df_bus[
        (df_bus["버스번호"].astype(str) == str(route)) &
        (df_bus["정류소명"].apply(clean_station_name) == station_clean) &
        (df_bus["season"] == season)
    ]
    if not matched.empty and time_col in matched.columns:
        return matched[time_col].mean() / 1040  # 1040명 기준 혼잡도 (비율로 반환)
    return 0.0

def get_path_congestion_score(path_nodes, now=None):
    """전체 경로의 평균 혼잡도 점수 계산"""
    hour, day_type, season = get_current_time_info(now)
    scores = []

    for node in path_nodes:
        info = parse_node(node)
        if info is None:
            continue

        if info["mode"] == "metro":
            score = get_metro_congestion(info["line"], info["station"], hour, day_type)
        else:
            score = get_bus_congestion(info["line"], info["station"], season, hour)

        scores.append(score)

    if not scores:
        return 0.0

    return sum(scores) / len(scores)

# 예시 테스트
example_path = ['3호선_종로3가', '3호선_을지로3가', '3호선_충무로', '3호선_약수', '3호선_금호']
example_score = get_path_congestion_score(example_path)

example_score

# -------------------------------
# 4. 지하철 노드 매핑 디버깅
# -------------------------------

# 경로 예시에서 파싱된 결과 확인
example_nodes = ['3호선_종로3가', '3호선_을지로3가', '3호선_충무로', '3호선_약수', '3호선_금호']
parsed_samples = [parse_node(n) for n in example_nodes]

# 각 노드에 대해 매칭 시도
hour, day_type, season = get_current_time_info()

debug_results = []
for node in example_nodes:
    info = parse_node(node)
    if not info:
        continue

    filtered = df_metro[
        (df_metro["호선"].astype(str) == info["line"].replace("호선", "")) &
        (df_metro["출발역"] == info["station"]) &
        (df_metro["요일구분"] == day_type)
    ]
    debug_results.append({
        "node": node,
        "parsed_line": info["line"],
        "parsed_station": info["station"],
        "matched_rows": len(filtered)
    })

debug_df = pd.DataFrame(debug_results)
debug_df

# -------------------------------
# 5. 특정 지하철역 시간컬럼의 값 확인
# -------------------------------

# 테스트용: '3호선' + '종로3가'
line = '3호선'
station = '종로3가'
hour, day_type, season = get_current_time_info()
time_str = f"{hour:02d}시00분"  # 예: "08시00분"

subset = df_metro[
    (df_metro["호선"].astype(str) == line.replace("호선", "")) &
    (df_metro["출발역"] == station) &
    (df_metro["요일구분"] == day_type)
]

# 확인용 출력
subset_result = subset[[col for col in subset.columns if "시" in col]].copy()
subset_result["선택된시간"] = subset[time_str] if time_str in subset.columns else "❌ 컬럼 없음"

subset_result[["선택된시간"]]

# -------------------------------
# 6. 시간 문자열 생성 방식 수정
# -------------------------------

# 출발역 정제
df_metro['출발역_clean'] = df_metro['출발역'].apply(clean_station_name)

# 다시 정의: 지하철 혼잡도 함수
# 메트로 혼잡도 함수 내부 시간 컬럼 선택 함수 수정 적용
def get_metro_congestion(line, station, now=None):
    if now is None:
        now = datetime.now(ZoneInfo("Asia/Seoul"))
    day_type = get_day_type(now)
    station_clean = clean_station_name(station)

    rows = df_metro[
        (df_metro['요일구분'] == day_type) &
        (df_metro['호선'].astype(str) == str(line)) &
        (df_metro['출발역_clean'] == station_clean)
    ]
    if rows.empty:
        print(f"[WARN] 매칭 실패: 호선={line}, 역={station_clean}, 요일={day_type}")
        return 0.0

    time_col = find_nearest_metro_timecol(now)
    if time_col not in rows.columns:
        print(f"[WARN] 시간 컬럼 없음: {time_col}")
        return 0.0

    try:
        val = float(rows.iloc[0][time_col])
        return val / 34.0  # 34명 기준 혼잡도
    except:
        return 0.0

# 최종 테스트
test_score_fixed_v2 = get_metro_congestion("3", "종로3가")
test_score_fixed_v2

# 1) 메트로 시간 컬럼 자동 추출
metro_time_cols = [c for c in df_metro.columns if re.match(r"\d{1,2}시\d{2}분", str(c))]

# 2) 가장 가까운 지하철 시간 컬럼 찾기
def find_nearest_metro_timecol(now=None):
    if now is None:
        now = datetime.now(ZoneInfo("Asia/Seoul"))
    t0 = now.hour * 60 + now.minute
    best_col = None
    min_diff = float("inf")
    for c in metro_time_cols:
        h, m = map(int, re.findall(r'\d+', c))
        t = h * 60 + m
        diff = abs(t - t0)
        if diff < min_diff:
            best_col = c
            min_diff = diff
    return best_col

# 3) 다시 메트로 혼잡도 함수에 반영해서 실행
test_score_fixed = get_metro_congestion("3", "종로3가")
test_score_fixed

# -------------------------------
# 정제: 버스 정류소 이름 전처리
# -------------------------------
def clean_station_name(raw):
    return re.sub(r"\(.*?\)", "", str(raw)).strip()

df_bus["정류소명_clean"] = df_bus["정류소명"].apply(clean_station_name)

# 계절 추출 유틸
def get_current_season(now):
    m = now.month
    if 3 <= m <= 5:
        return "spring"
    elif 6 <= m <= 8:
        return "summer"
    elif 9 <= m <= 11:
        return "fall"
    return "winter"

# 날짜 정보 변환 유틸
def get_day_type(now):
    wd = now.weekday()
    return "평일" if wd < 5 else ("토요일" if wd == 5 else "일요일")

# 가장 가까운 시간대 열 찾기
def find_nearest_bus_timecol(now):
    return f"{now.hour}시총승객수"

# 버스 혼잡도 함수
def get_bus_passenger_congestion(route, station, season=None, now=None):
    if now is None:
        now = datetime.now(ZoneInfo("Asia/Seoul"))
    if season is None:
        season = get_current_season(now)
    route = str(route)
    station_clean = clean_station_name(station)
    rows = df_bus[
        (df_bus['버스번호'] == route) &
        (df_bus['정류소명_clean'] == station_clean) &
        (df_bus['season'] == season)
    ]
    if rows.empty:
        return 0.0
    time_col = find_nearest_bus_timecol(now)
    val = rows.iloc[0].get(time_col, 0)
    try:
        return float(val) / (20* 26.0)
    except:
        return 0.0

# 지역별 버스 속도 기반 혼잡도
def get_bus_speed_congestion(region, now=None):
    if now is None:
        now = datetime.now(ZoneInfo("Asia/Seoul"))
    season = get_current_season(now)
    rows = df_speed[df_speed['지역별'] == region]
    if rows.empty:
        return 0.0
    try:
        return float(rows.iloc[0][season]) / 22.7
    except:
        return 0.0

# edge_congestion 및 calc_route_congestion 연결
def edge_congestion(u, v, G, now=None):
    if now is None:
        now = datetime.now(ZoneInfo("Asia/Seoul"))
    mode = G[u][v].get('mode', None)

    if mode == 'metro_edge':
        line = G.nodes[u].get('line_clean')
        station = G.nodes[u].get('station_clean')
        return get_metro_congestion(line, station, now=now)

    elif mode == 'bus_edge':
        route = G.nodes[u].get('route_clean')
        station = G.nodes[u].get('station_clean')
        region = G.nodes[u].get('region', None)
        if route is None or station is None:
            return 0.0
        passenger_cong = get_bus_passenger_congestion(route, station, now=now)
        speed_cong = get_bus_speed_congestion(region, now=now) if region else 0.0
        return (passenger_cong + speed_cong) / 2.0

    else:
        # transfer or unknown
        return 0.0

def calc_route_congestion(path, G, now=None):
    if now is None:
        now = datetime.now(ZoneInfo("Asia/Seoul"))
    scores = []
    for u, v in zip(path, path[1:]):
        score = edge_congestion(u, v, G, now=now)
        scores.append(score)
    return np.mean(scores) if scores else 0.0

score = calc_route_congestion(path, integrated_graph)
print("경로 평균 혼잡도:", score)

# 쾌적도 버전과 동일한 구조로 혼잡도 기반 결과 출력 예시 함수 정의
def print_least_congested_routes(routes, G, top_k=3, now=None):
    print(f"\n[혼잡도 기반 상위 {top_k} 경로]")
    for i, r in enumerate(routes[:top_k], 1):
        path = r['path']
        score = calc_route_congestion(path, G, now=now)
        print(f"\n[{i}위] 평균혼잡도={score:.3f}, "
              f"총시간={r['time_min']:.1f}분 (보행={r['walk_min']:.1f}분, 환승={r['transfers']}회)")
        print("경로:", " → ".join(path))

print_least_congested_routes(least_congested, integrated_graph, top_k=100)

def get_metro_congestion(line, station, now=None):
    if now is None:
        now = datetime.now(ZoneInfo("Asia/Seoul"))
    day_type = get_day_type(now)
    station_clean = clean_station_name(station)

    rows = df_metro[
        (df_metro['요일구분'] == day_type) &
        (df_metro['호선'].astype(str) == str(line)) &
        (df_metro['출발역'].apply(clean_station_name) == station_clean)
    ]

    if rows.empty:
        print(f"[WARN] 매칭 실패: 호선={line}, 역={station_clean}, 요일={day_type}")
        return 0.0

    time_col = find_nearest_metro_timecol(now)
    if time_col not in rows.columns:
        print(f"[WARN] 시간 컬럼 없음: {time_col}")
        return 0.0

    try:
        val = float(rows.iloc[0][time_col])
        return val / 34.0  # 좌석 기준
    except:
        return 0.0

# 예: 종로3가 3호선 확인
now = datetime.now(ZoneInfo("Asia/Seoul"))
get_metro_congestion('3', '종로3가', now)

print(df_metro['호선'].unique())  # '3' 형태인지 '3호선' 형태인지

def get_bus_passenger_congestion(route, station, now=None):
    if now is None:
        now = datetime.now(ZoneInfo("Asia/Seoul"))
    route = str(route).zfill(3)
    station_clean = clean_station_name(station)
    season = get_current_season(now)
    time_col = f"{now.hour}시총승객수"
    print(f"[DEBUG] 버스 혼잡도 매핑: route={route}, station={station_clean}, season={season}, time_col={time_col}")

    # df_bus: ['season', '버스번호', '정류소명_clean', ...]
    df = df_bus[
        (df_bus['버스번호'] == route) &
        (df_bus['season'] == season) &
        (df_bus['정류소명_clean'] == station_clean)
    ]
    if df.empty:
        print(f"[WARN] 버스 혼잡도 없음: route='{route}' station='{station_clean}' season='{season}'")
        return 0.0
    row = df.iloc[0]
    if time_col not in df_bus.columns:
        print(f"[WARN] 버스 시간 컬럼 없음: {time_col}")
        return 0.0
    val = float(row[time_col]) / (40 * 26)
    return val

def calc_route_congestion(path, G, now=None):
    scores = []
    for u, v in zip(path, path[1:]):
        s = edge_congestion(u, v, G, now=now)
        print(f"edge: {u}→{v} 혼잡도={s:.4f}")
        scores.append(s)
    if not scores:
        return 0.0
    print(f"[RESULT] 경로 평균 혼잡도: {np.mean(scores):.4f}")
    return np.mean(scores)

def find_nearest_metro_timecol(now=None):
    if now is None:
        now = datetime.now(ZoneInfo("Asia/Seoul"))
    t0 = now.hour * 60 + now.minute
    best_col = None
    min_diff = 1e9
    for c in metro_time_cols:
        # ‘5시30분’ → 분으로 변환
        h, m = int(c.split('시')[0]), int(c.split('시')[1].replace('분', ''))
        t = h * 60 + m
        diff = abs(t - t0)
        if diff < min_diff:
            min_diff = diff
            best_col = c
    return best_col

def find_nearest_bus_timecol(now=None):
    if now is None:
        now = datetime.now(ZoneInfo("Asia/Seoul"))
    h = now.hour
    return f"{h}시총승객수"

def get_metro_congestion(line, station, now=None):
    if now is None:
        now = datetime.now(ZoneInfo("Asia/Seoul"))
    day_type = get_day_type(now)
    line_q = line if isinstance(line, str) else str(line)
    station_clean = clean_station_name(station)
    # ‘호선’은 int로 되어 있을 수도, str로 되어 있을 수도 있음
    rows = df_metro[
        (df_metro['요일구분'] == day_type) &
        (df_metro['호선'].astype(str) == line_q) &
        (df_metro['출발역_clean'] == station_clean)
    ]
    if rows.empty:
        print(f"[WARN] 메트로 혼잡도 없음: line='{line}', station='{station}', day_type='{day_type}'")
        return 0.0
    time_col = find_nearest_metro_timecol(now)
    val = rows.iloc[0][time_col]
    try:
        return float(val) / 34.0   # 좌석수 기준 혼잡도
    except:
        return 0.0

def get_bus_passenger_congestion(route, station, season=None, now=None):
    if now is None:
        now = datetime.now(ZoneInfo("Asia/Seoul"))
    if season is None:
        season = get_current_season(now)
    route = str(route)
    station_clean = clean_station_name(station)
    rows = df_bus[
        (df_bus['버스번호'] == route) &
        (df_bus['정류소명_clean'] == station_clean) &
        (df_bus['season'] == season)
    ]
    if rows.empty:
        print(f"[WARN] 버스 혼잡도 없음: route='{route}' station='{station}' season='{season}'")
        return 0.0
    time_col = find_nearest_bus_timecol(now)
    val = rows.iloc[0][time_col]
    try:
        return float(val) / (40.0 * 26.0)   # 좌석수×버스대수 기준 혼잡도
    except:
        return 0.0

# df_speed: 지역별, 계절별 속도
def get_bus_speed_congestion(region, now=None):
    if now is None:
        now = datetime.now(ZoneInfo("Asia/Seoul"))
    season = get_current_season(now)
    rows = df_speed[df_speed['지역별'] == region]
    if rows.empty:
        print(f"[WARN] 버스 속도 혼잡도 없음: region='{region}'")
        return 0.0
    try:
        # 평균속도 ÷ 22.7로 혼잡도(비율)
        return float(rows.iloc[0][season]) / 22.7
    except:
        return 0.0

def edge_congestion(u, v, G, now=None):
    mode = G[u][v].get('mode')
    if now is None:
        now = datetime.now(ZoneInfo("Asia/Seoul"))

    if mode == 'metro_edge':
        line    = G.nodes[u].get('line')
        station = G.nodes[u].get('station')
        return get_metro_congestion(line, station, now)

    elif mode == 'bus_edge':
        # "노선번호_정류장명" 구조
        route, station = u.split('_', 1)
        region = G.nodes[u].get('region', None)
        psg = get_bus_passenger_congestion(route, station, now=now)
        spd = get_bus_speed_congestion(region, now) if region else 0.0
        return (psg + spd) / 2.0

    else:
        # transfer 등
        return 0.0

def test_bus_congestion(route, station, season, hour):
    time_col = f"{hour}시총승객수"
    station_clean = clean_station_name(station)
    rows = df_bus[
        (df_bus['버스번호'] == str(route)) &
        (df_bus['정류소명_clean'] == station_clean) &
        (df_bus['season'] == season)
    ]
    print(f"[TEST] route={route}, station={station}, season={season}, time_col={time_col}")
    if rows.empty:
        print(f"⛔ NO MATCH for (버스번호: {route}, 정류소명: {station}, 시즌: {season}, 시간: {time_col})")
        print("   >> 실제 unique 버스번호:", df_bus['버스번호'].unique()[:10])
        print("   >> 실제 unique 정류소명_clean:", df_bus['정류소명_clean'].unique()[:10])
        print("   >> 실제 unique season:", df_bus['season'].unique())
    else:
        v = float(rows.iloc[0][time_col])
        print(f"  혼잡도(잔여승객/1040): {v} / (40*26)")

def test_metro_congestion(line, station, now=None):
    print(f"[TEST] line={line}, station={station}")
    v = get_metro_congestion(line, station, now)
    print(f"  혼잡도: {v}")

for node, data in integrated_graph.nodes(data=True):
    # 버스: "노선번호_정류장명"
    if data.get('mode') == 'bus':
        try:
            route, station = node.split('_', 1)
            data['route_clean'] = str(route).zfill(3)  # 앞자리 0 맞추기 ('140'→'140', '17'→'017')
            data['station_clean'] = clean_station_name(station)
        except Exception as e:
            data['route_clean'] = None
            data['station_clean'] = None

    # 지하철: "3호선_종로3가" 등
    elif data.get('mode') == 'metro':
        try:
            if '_' in node:
                line, station = node.split('_', 1)
                # 호선: '3호선' → '3' 또는 '신분당선' 등. 데이터와 통일!
                # df_metro['호선']이 '3'형태면 int/str로 통일
                if re.match(r'^\d+$', line.replace('호선', '')):
                    line_clean = line.replace('호선', '')
                else:
                    line_clean = line  # 예: '신분당선'
                data['line_clean'] = str(line_clean)
                data['station_clean'] = clean_station_name(station)
            else:
                data['line_clean'] = None
                data['station_clean'] = clean_station_name(node)
        except Exception as e:
            data['line_clean'] = None
            data['station_clean'] = None

def calc_route_congestion(path, G, now=None):
    if now is None:
        now = datetime.now(ZoneInfo("Asia/Seoul"))
    scores = []
    for u, v in zip(path, path[1:]):
        score = edge_congestion(u, v, G, now=now)
        scores.append(score)
    if not scores:
        return 0.0
    return np.mean(scores)  # 평균 혼잡도 (합산은 np.sum(scores))

for i, route_info in enumerate(least_congested, 1):
    path = route_info['path']
    score = calc_route_congestion(path, integrated_graph)
    print(f"[{i}위] 경로 평균혼잡도={score:.3f}")
    print("경로:", " → ".join(path))

"""# 여기서부터는 참고"""

def get_least_transfer_routes_optimized(G, origin_candidates, dest_candidates, k=10, max_transfers=4):
    """
    - transfer_weight: 엣지별 “환승시 10000 패널티 + 통행시간” 으로 가중치 계산
    """
    def transfer_weight(u, v, edge_data):
        mode = edge_data.get('mode')
        w = edge_data.get('weight', 0)
        if mode == 'transfer':
            return 10000 + w
        if mode == 'metro_edge':
            lu = G.nodes[u].get('line')
            lv = G.nodes[v].get('line')
            if lu is None or lv is None or lu != lv:
                return 10000 + w
            return w
        if mode == 'bus_edge':
            return w
        return w

    least_transfer_list = []

    for origin_node, origin_walk in origin_candidates:
        # 1) origin_node 한 번에 Dijkstra → distances, paths 얻기
        distances, paths = nx.single_source_dijkstra(
            G,
            origin_node,
            weight=transfer_weight
        )

        for dest_node, dest_walk in dest_candidates:
            if dest_node not in distances:
                continue

            # (a) distances[dest_node]에는 “환승 패널티 포함 + 내부 통행시간”이 누적된 값
            # → 실제 여행 시간(내부 교통시간)만 따로 계산하려면 경로를 순회해야 함.
            path = paths[dest_node]

            # 2) 실제 환승 횟수 계산 (기존과 동일)
            transfer_count = 0
            prev_mode, prev_line = None, None
            edges = list(zip(path, path[1:]))

            for idx, (u, v) in enumerate(edges):
                ed = G[u][v]
                mode = ed.get('mode')
                if mode == 'transfer':
                    if idx != 0 and idx != (len(edges) - 1):
                        transfer_count += 1
                    prev_mode, prev_line = 'transfer', None
                    continue
                if mode == 'metro_edge':
                    cur_line = G.nodes[u].get('line')
                    if prev_mode == 'metro_edge' and prev_line != cur_line:
                        transfer_count += 1
                    prev_mode, prev_line = 'metro_edge', cur_line
                    continue
                if mode == 'bus_edge':
                    cur_br = next(iter(ed.get('lines', [])), None)
                    if prev_mode == 'bus_edge' and prev_line != cur_br:
                        transfer_count += 1
                    prev_mode, prev_line = 'bus_edge', cur_br
                    continue
                prev_mode, prev_line = mode, None

            if transfer_count > max_transfers:
                continue

            # 3) 실제 내부 통행시간(버스/지하철/환승 weight)은 경로를 순회하며 직접 합산
            travel_time = sum(G[u][v]['weight'] for u, v in edges)

            total_time = travel_time + origin_walk + dest_walk
            total_walk = origin_walk + dest_walk

            least_transfer_list.append({
                'path': path,
                'time_min': total_time,
                'transfers': transfer_count,
                'walk_min': total_walk
            })

    # 4) (환승 횟수, 총 시간) 기준으로 정렬
    least_transfer_list.sort(key=lambda x: (x['transfers'], x['time_min']))
    return least_transfer_list[:k]

def get_least_walking_routes_optimized(G, origin_candidates, dest_candidates, k=10, max_transfers=4):
    def walk_only_weight(u, v, edge_data):
        return edge_data['weight'] if edge_data.get('mode') == 'transfer' else 0

    least_walking_list = []

    for origin_node, origin_walk in origin_candidates:
        # 1) origin_node 한 번에 Dijkstra → distances, paths
        distances, paths = nx.single_source_dijkstra(
            G,
            origin_node,
            weight=walk_only_weight
        )

        for dest_node, dest_walk in dest_candidates:
            if dest_node not in distances:
                continue

            # (a) distances[dest_node] = “경로 중 transfer weight 합”
            walk_length_along_graph = distances[dest_node]
            path = paths[dest_node]

            # 2) 환승 횟수 계산 (기존 로직과 동일)
            transfer_count = 0
            prev_mode, prev_line = None, None
            edges = list(zip(path, path[1:]))

            for idx, (u, v) in enumerate(edges):
                ed = G[u][v]
                mode = ed.get('mode')
                if mode == 'transfer':
                    if 0 < idx < (len(edges)-1):
                        transfer_count += 1
                    prev_mode, prev_line = 'transfer', None
                    continue
                if mode == 'metro_edge':
                    cur_line = G.nodes[u].get('line')
                    if prev_mode == 'metro_edge' and prev_line != cur_line:
                        transfer_count += 1
                    prev_mode, prev_line = 'metro_edge', cur_line
                    continue
                if mode == 'bus_edge':
                    cur_br = next(iter(ed.get('lines', [])), None)
                    if prev_mode == 'bus_edge' and prev_line != cur_br:
                        transfer_count += 1
                    prev_mode, prev_line = 'bus_edge', cur_br
                    continue
                prev_mode, prev_line = mode, None

            if transfer_count > max_transfers:
                continue

            total_walk = walk_length_along_graph + origin_walk + dest_walk
            travel_time = sum(G[u][v]['weight'] for u, v in edges)
            total_time = travel_time + origin_walk + dest_walk

            least_walking_list.append({
                'path': path,
                'time_min': total_time,
                'transfers': transfer_count,
                'walk_min': total_walk
            })

    least_walking_list.sort(key=lambda x: (x['walk_min'], x['time_min']))
    return least_walking_list[:k]

def get_top_routes_optimized(G, origin_candidates, dest_candidates, k_per_criteria=10, max_transfers=4):
    return {
        'fastest': get_fastest_routes_optimized(G, origin_candidates, dest_candidates,
                                                k=k_per_criteria, max_transfers=max_transfers),
        'least_transfers': get_least_transfer_routes_optimized(G, origin_candidates, dest_candidates,
                                                                k=k_per_criteria, max_transfers=max_transfers),
        'least_walking': get_least_walking_routes_optimized(G, origin_candidates, dest_candidates,
                                                            k=k_per_criteria, max_transfers=max_transfers)
    }

# 4) 실제 호출 예시:
results = get_top_routes_optimized(
    integrated_graph,
    start_nodes_with_walk,   # 반경 500m 이내 후보 + 도로망 기반 도보 시간
    end_nodes_with_walk,
    k_per_criteria=10,       # 각 기준별 상위 10개
    max_transfers=4
)

# 5) 결과 출력
for criterion, routes in results.items():
    print(f"=== {criterion.upper()} ROUTES (max_transfers=4) ===")
    for idx, route in enumerate(routes, 1):
        path_str = " → ".join(route['path'])
        print(f"[{idx}] 경로: {path_str}")
        print(f"     총시간: {route['time_min']:.1f}분 | 환승: {route['transfers']}회 | 도보: {route['walk_min']:.1f}분")
    print()

"""########

서울교통공사 1-8호선 30분 단위 평균 혼잡도로 30분간 지나는 열차들의 평균 혼잡도(정원대비 승차인원으로, 승차인과 좌석수가 일치할 경우를 혼잡도 34%로 산정) 입니다.(단위: %).
서울교통공사 혼잡도 데이터는 요일구분(평일, 토요일, 일요일), 호선, 역번호, 역명, 상하선구분, 30분단위 별 혼잡도 데이터로 구성되어 있습니다. (2024년부터 분기별 제공됩니다.)

일반적인 시내버스(도시표준형)의 경우, 좌석수는 21석, 입석은 40석, 운전석을 포함하여 총 62명까지 탑승 가능합니다. 광역버스나 직행좌석버스는 좌석 수가 더 많거나 2층 버스의 경우 70석 이상이 될 수도 있습니다.

배차간격 10분.
"""